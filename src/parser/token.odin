#+feature dynamic-literals
package parser

import "core:fmt"

TokenType :: enum u8 {
	Identifier,
	Exclamation,
	Question,
	Number,
	// symbols
	Comma,
	Dot,
	DotDot,
	DotDotEq,
	Quote,
	Hash,
	DoubleQuote,
	LParen,
	RParen,
	LBrack,
	RBrack,
	LBrace,
	RBrace,
	Colon,
	ColonColon,
	ColonEQ,
	SemiColon,
	Bar,
	Pipe,
	LT,
	GT,
	EQ,
	LEQ,
	GEQ,
	NEQ,
	EQEQ,
	Arrow,
	Plus,
	PlusEQ,
	Minus,
	MinusEQ,
	Multiply,
	MultiplyEQ,
	Divide,
	DivideEQ,
	// keywords
	Return,
	For,
	In,
	If,
	Else,
	True,
	False,
	Import,
	Continue,
	Break,
	And,
	Or,
	Switch,
	Case,
	Defer,
	Struct,
	Enum,
	Union,
	OrElse,
	OrReturn,
	// Datatypes 
	Bool,
	String,
	Char,
	Int,
	Uint,
	F8,
	F16,
	F32,
	F64,
	I8,
	I16,
	I32,
	I64,
	U8,
	U16,
	U32,
	U64,

	// Extras
	Invalid,
	Eof,
}

Directives: [dynamic]string = {"inline", "no_inline", "no_bounds_check", "bounds_check"}

// Token Keywords
KEYWORDS: map[string]TokenType = {
	"for"       = .For,
	"in"        = .In,
	"if"        = .If,
	"else"      = .Else,
	"true"      = .True,
	"false"     = .False,
	"import"    = .Import,
	"return"    = .Return,
	"continue"  = .Continue,
	"break"     = .Break,
	"and"       = .And,
	"or"        = .Or,
	"switch"    = .Switch,
	"case"      = .Case,
	"defer"     = .Defer,
	"struct"    = .Struct,
	"enum"      = .Enum,
	"union"     = .Union,
	"or_else"   = .OrElse,
	"or_return" = .OrReturn,
	"bool"      = .Bool,
	"str"       = .String,
	"char"      = .Char,
	"int"       = .Int,
	"uint"      = .Uint,
	"f8"        = .F8,
	"f16"       = .F16,
	"f32"       = .F32,
	"f64"       = .F64,
	"i8"        = .I8,
	"i16"       = .I16,
	"i32"       = .I32,
	"i64"       = .I64,
	"u8"        = .U8,
	"u16"       = .U16,
	"u32"       = .U32,
	"u64"       = .U64,
}

Token :: struct {
	type:    TokenType,
	literal: string,
	col:     int,
	line:    int,
}


print_token :: proc(token: Token) {
	fmt.println(token.type, token.literal, "Line:", token.line, "Col:", token.col)
}
